<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>coreSNTP: Callback Types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">coreSNTP<span id="projectnumber">&#160;v1.1.0</span>
   </div>
   <div id="projectbrief">Client library for synchronizing device time with internet time using Simple Network Time Protocol (SNTP)</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__sntp__callback__types.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle"><div class="title">Callback Types</div></div>
</div><!--header-->
<div class="contents">

<p>Callback function pointer types of the coreSNTP library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaef268b4cc2cf00e3e573b637cde7c09e"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sntp__callback__types.html#gaef268b4cc2cf00e3e573b637cde7c09e">SntpResolveDns_t</a>) (const <a class="el" href="struct_sntp_server_info__t.html">SntpServerInfo_t</a> *pServerAddr, uint32_t *pIpV4Addr)</td></tr>
<tr class="memdesc:gaef268b4cc2cf00e3e573b637cde7c09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for user-defined function to resolve time server domain-name to an IPv4 address. The SNTP client library attempts to resolve the DNS of the time-server being used every time the <a class="el" href="core__sntp__client_8h.html#ae6cb1fe85cff973b2cfa73751adb4062">Sntp_SendTimeRequest</a> API is called.  <a href="group__sntp__callback__types.html#gaef268b4cc2cf00e3e573b637cde7c09e">More...</a><br /></td></tr>
<tr class="separator:gaef268b4cc2cf00e3e573b637cde7c09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e30d57887e46bee4074a5ba62f681e8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sntp__callback__types.html#ga1e30d57887e46bee4074a5ba62f681e8">SntpGetTime_t</a>) (<a class="el" href="struct_sntp_timestamp__t.html">SntpTimestamp_t</a> *pCurrentTime)</td></tr>
<tr class="memdesc:ga1e30d57887e46bee4074a5ba62f681e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for user-defined function to obtain the current system time in SNTP timestamp format.  <a href="group__sntp__callback__types.html#ga1e30d57887e46bee4074a5ba62f681e8">More...</a><br /></td></tr>
<tr class="separator:ga1e30d57887e46bee4074a5ba62f681e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade7b1a15684e1272ef7dbb9e4486c285"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sntp__callback__types.html#gade7b1a15684e1272ef7dbb9e4486c285">SntpSetTime_t</a>) (const <a class="el" href="struct_sntp_server_info__t.html">SntpServerInfo_t</a> *pTimeServer, const <a class="el" href="struct_sntp_timestamp__t.html">SntpTimestamp_t</a> *pServerTime, int64_t clockOffsetMs, <a class="el" href="group__sntp__enum__types.html#ga69e2cb17ab4e253491602ccfe48b141f">SntpLeapSecondInfo_t</a> leapSecondInfo)</td></tr>
<tr class="memdesc:gade7b1a15684e1272ef7dbb9e4486c285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for user-defined function to update the system clock time so that it is synchronized the time server used for getting current time.  <a href="group__sntp__callback__types.html#gade7b1a15684e1272ef7dbb9e4486c285">More...</a><br /></td></tr>
<tr class="separator:gade7b1a15684e1272ef7dbb9e4486c285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadd728af5c040252f0b7224e72ea771f"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sntp__callback__types.html#gaadd728af5c040252f0b7224e72ea771f">UdpTransportSendTo_t</a>) (<a class="el" href="group__sntp__struct__types.html#ga7769e434e7811caed8cd6fd7f9ec26ec">NetworkContext_t</a> *pNetworkContext, uint32_t serverAddr, uint16_t serverPort, const void *pBuffer, uint16_t bytesToSend)</td></tr>
<tr class="memdesc:gaadd728af5c040252f0b7224e72ea771f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for user-defined function to send time request as a single datagram to server on the network over User Datagram Protocol (UDP).  <a href="group__sntp__callback__types.html#gaadd728af5c040252f0b7224e72ea771f">More...</a><br /></td></tr>
<tr class="separator:gaadd728af5c040252f0b7224e72ea771f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga138d8e928110f9b0cbc214135c91b344"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sntp__callback__types.html#ga138d8e928110f9b0cbc214135c91b344">UdpTransportRecvFrom_t</a>) (<a class="el" href="group__sntp__struct__types.html#ga7769e434e7811caed8cd6fd7f9ec26ec">NetworkContext_t</a> *pNetworkContext, uint32_t serverAddr, uint16_t serverPort, void *pBuffer, uint16_t bytesToRecv)</td></tr>
<tr class="memdesc:ga138d8e928110f9b0cbc214135c91b344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for user-defined function to receive the server response, to a time request (sent through the <a class="el" href="group__sntp__callback__types.html#gaadd728af5c040252f0b7224e72ea771f">UdpTransportSendTo_t</a> function), from the network over User Datagram Protocol (UDP).  <a href="group__sntp__callback__types.html#ga138d8e928110f9b0cbc214135c91b344">More...</a><br /></td></tr>
<tr class="separator:ga138d8e928110f9b0cbc214135c91b344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f01446c0d655614b99fd4043c8f032a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__sntp__enum__types.html#gaef7b22d8008bbfbbc7bbea5a7a30e798">SntpStatus_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sntp__callback__types.html#ga7f01446c0d655614b99fd4043c8f032a">SntpGenerateAuthCode_t</a>) (<a class="el" href="group__sntp__struct__types.html#gaff243b342eebc2622fbb493d08663133">SntpAuthContext_t</a> *pContext, const <a class="el" href="struct_sntp_server_info__t.html">SntpServerInfo_t</a> *pTimeServer, void *pBuffer, size_t bufferSize, uint16_t *pAuthCodeSize)</td></tr>
<tr class="memdesc:ga7f01446c0d655614b99fd4043c8f032a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for user-defined function to generate and append authentication code in an SNTP request buffer for the SNTP client to be authenticated by the time server, if a security mechanism is used.  <a href="group__sntp__callback__types.html#ga7f01446c0d655614b99fd4043c8f032a">More...</a><br /></td></tr>
<tr class="separator:ga7f01446c0d655614b99fd4043c8f032a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae382a67b0ffbb4721d8d599efe3020c4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__sntp__enum__types.html#gaef7b22d8008bbfbbc7bbea5a7a30e798">SntpStatus_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sntp__callback__types.html#gae382a67b0ffbb4721d8d599efe3020c4">SntpValidateServerAuth_t</a>) (<a class="el" href="group__sntp__struct__types.html#gaff243b342eebc2622fbb493d08663133">SntpAuthContext_t</a> *pContext, const <a class="el" href="struct_sntp_server_info__t.html">SntpServerInfo_t</a> *pTimeServer, const void *pResponseData, uint16_t responseSize)</td></tr>
<tr class="memdesc:gae382a67b0ffbb4721d8d599efe3020c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for user-defined function to authenticate server by validating the authentication code present in its SNTP response to a time request, if a security mechanism is supported by the server.  <a href="group__sntp__callback__types.html#gae382a67b0ffbb4721d8d599efe3020c4">More...</a><br /></td></tr>
<tr class="separator:gae382a67b0ffbb4721d8d599efe3020c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Callback function pointer types of the coreSNTP library. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaef268b4cc2cf00e3e573b637cde7c09e" name="gaef268b4cc2cf00e3e573b637cde7c09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef268b4cc2cf00e3e573b637cde7c09e">&#9670;&nbsp;</a></span>SntpResolveDns_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* SntpResolveDns_t) (const <a class="el" href="struct_sntp_server_info__t.html">SntpServerInfo_t</a> *pServerAddr, uint32_t *pIpV4Addr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface for user-defined function to resolve time server domain-name to an IPv4 address. The SNTP client library attempts to resolve the DNS of the time-server being used every time the <a class="el" href="core__sntp__client_8h.html#ae6cb1fe85cff973b2cfa73751adb4062">Sntp_SendTimeRequest</a> API is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pServerAddr</td><td>The time-server whose IPv4 address is to be resolved. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pIpV4Addr</td><td>This should be filled with the resolved IPv4 address. of <code>pTimeServer</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if DNS resolution is successful; otherwise <code>false</code> to represent failure. </dd></dl>

</div>
</div>
<a id="ga1e30d57887e46bee4074a5ba62f681e8" name="ga1e30d57887e46bee4074a5ba62f681e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e30d57887e46bee4074a5ba62f681e8">&#9670;&nbsp;</a></span>SntpGetTime_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SntpGetTime_t) (<a class="el" href="struct_sntp_timestamp__t.html">SntpTimestamp_t</a> *pCurrentTime)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface for user-defined function to obtain the current system time in SNTP timestamp format. </p>
<dl class="section note"><dt>Note</dt><dd>If your platform follows UNIX representation of time, the <a class="el" href="group__sntp__constants.html#gae20ed1490028cf58b01e69af5f2aa635" title="The seconds part of SNTP time at the UNIX epoch time, which represents an offset of 70 years (in seco...">SNTP_TIME_AT_UNIX_EPOCH_SECS</a> and <a class="el" href="group__sntp__constants.html#ga1baca7c2b918d398acbc5f9412c01ebd" title="Number of SNTP timestamp fractions in 1 microsecond.">SNTP_FRACTION_VALUE_PER_MICROSECOND</a> macros can be used to convert UNIX time to SNTP timestamp.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pCurrentTime</td><td>This should be filled with the current system time in SNTP timestamp format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if obtaining system time is successful; otherwise <code>false</code> to represent failure. </dd></dl>

</div>
</div>
<a id="gade7b1a15684e1272ef7dbb9e4486c285" name="gade7b1a15684e1272ef7dbb9e4486c285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade7b1a15684e1272ef7dbb9e4486c285">&#9670;&nbsp;</a></span>SntpSetTime_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SntpSetTime_t) (const <a class="el" href="struct_sntp_server_info__t.html">SntpServerInfo_t</a> *pTimeServer, const <a class="el" href="struct_sntp_timestamp__t.html">SntpTimestamp_t</a> *pServerTime, int64_t clockOffsetMs, <a class="el" href="group__sntp__enum__types.html#ga69e2cb17ab4e253491602ccfe48b141f">SntpLeapSecondInfo_t</a> leapSecondInfo)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface for user-defined function to update the system clock time so that it is synchronized the time server used for getting current time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimeServer</td><td>The time server used to request time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pServerTime</td><td>The current time returned by the <code>pTimeServer</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clockOffsetMs</td><td>The calculated clock offset (in milliseconds) of the system relative to the server time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leapSecondInfo</td><td>Information about whether there is about an upcoming leap second adjustment of insertion or deletion in the last minute before midnight on the last day of the current month. For more information on leap seconds, refer to <a href="https://www.nist.gov/pml/time-and-frequency-division/leap-seconds-faqs">https://www.nist.gov/pml/time-and-frequency-division/leap-seconds-faqs</a>. Depending on the accuracy requirements of the system clock, the user can choose to account for the leap second or ignore it in their system clock update logic.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the <code>clockOffsetMs</code> is positive, then the system time is BEHIND the server time, and if the <code>clockOffsetMs</code>, the system time is AHEAD of the server time. To correct the system time, the user can use either of "step", "slew" OR combination of the two clock discipline methodologies depending on the application needs. If the application requires a smooth time continuum of system time, then the "slew" discipline methodology can be used with the clock offset value, <code>clockOffSetMs</code>, to correct the system clock gradually with a "slew rate". If the application can accept sudden jump in time (forward or backward), then the "step" discipline methodology can be used to directly update the system clock with the current server time, <code>pServerTime</code>, every time the coreSNTP library calls the interface. </dd></dl>

</div>
</div>
<a id="gaadd728af5c040252f0b7224e72ea771f" name="gaadd728af5c040252f0b7224e72ea771f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadd728af5c040252f0b7224e72ea771f">&#9670;&nbsp;</a></span>UdpTransportSendTo_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* UdpTransportSendTo_t) (<a class="el" href="group__sntp__struct__types.html#ga7769e434e7811caed8cd6fd7f9ec26ec">NetworkContext_t</a> *pNetworkContext, uint32_t serverAddr, uint16_t serverPort, const void *pBuffer, uint16_t bytesToSend)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface for user-defined function to send time request as a single datagram to server on the network over User Datagram Protocol (UDP). </p>
<dl class="section note"><dt>Note</dt><dd>It is RECOMMENDED that the send operation is non-blocking, i.e. it SHOULD immediately return when the entire UDP data cannot be sent over the network. In such a case, the coreSNTP library will re-try send operation for a maximum period of blocking time passed to the <a class="el" href="core__sntp__client_8h.html#ae6cb1fe85cff973b2cfa73751adb4062">Sntp_SendTimeRequest</a> API.</dd>
<dd>
If the size of the SNTP packet exceeds the Maximum Transmission Unit (MTU) supported by the network interface of the device, the user-defined implementation MAY either support fragmentation of UDP packets OR use a size for authentication data that allows the SNTP packet to fit within the MTU required size threshold. (Note that the size of SNTP packet is <a class="el" href="group__sntp__constants.html#ga9fb0febdb6e2f2dff2e133ef49ce205b" title="The base packet size of request and response of the (S)NTP protocol.">SNTP_PACKET_BASE_SIZE</a> + authentication data.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pNetworkContext</td><td>The user defined NetworkContext_t which is opaque to the coreSNTP library. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">serverAddr</td><td>The IPv4 address of the time server to send the data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">serverPort</td><td>The port of the server to send data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>The buffer containing the data to send over the network. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytesToSend</td><td>The size of data in <code>pBuffer</code> to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function SHOULD return one of the following integer codes:<ul>
<li><code>bytesToSend</code> when all requested data is successfully transmitted over the network.</li>
<li>0 when no data could be sent over the network (due to network buffer being full, for example), and the send operation can be retried.</li>
<li>&lt; 0 when the send operation failed to send any data due to an internal error, and operation cannot be retried. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga138d8e928110f9b0cbc214135c91b344" name="ga138d8e928110f9b0cbc214135c91b344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga138d8e928110f9b0cbc214135c91b344">&#9670;&nbsp;</a></span>UdpTransportRecvFrom_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* UdpTransportRecvFrom_t) (<a class="el" href="group__sntp__struct__types.html#ga7769e434e7811caed8cd6fd7f9ec26ec">NetworkContext_t</a> *pNetworkContext, uint32_t serverAddr, uint16_t serverPort, void *pBuffer, uint16_t bytesToRecv)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface for user-defined function to receive the server response, to a time request (sent through the <a class="el" href="group__sntp__callback__types.html#gaadd728af5c040252f0b7224e72ea771f">UdpTransportSendTo_t</a> function), from the network over User Datagram Protocol (UDP). </p>
<dl class="section note"><dt>Note</dt><dd>It is RECOMMENDED that the read operation is non-blocking, i.e. it SHOULD immediately return when no data is available on the network. In such a case, the coreSNTP library will re-try send operation for a maximum period of blocking time passed through the <a class="el" href="core__sntp__client_8h.html#ab077d90d19e70a33ab08b31f48728ba5">Sntp_ReceiveTimeResponse</a> API.</dd>
<dd>
If the size of the SNTP response packet from the server exceeds the Maximum Transmission Unit (MTU) supported by the network interface of the device, the user-defined implementation of the interface MAY either support receiving and assembling fragmented UDP packets OR use an authentication data size that allows SNTP packet to fit within the MTU required packet size threshold. (Note that the size of SNTP packet is <a class="el" href="group__sntp__constants.html#ga9fb0febdb6e2f2dff2e133ef49ce205b" title="The base packet size of request and response of the (S)NTP protocol.">SNTP_PACKET_BASE_SIZE</a> + authentication data.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pNetworkContext</td><td>The user defined NetworkContext_t which is opaque to the coreSNTP library. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">serverAddr</td><td>The IPv4 address of the time server to receive data from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">serverPort</td><td>The port of the server to receive data from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pBuffer</td><td>This SHOULD be filled with data received from the network. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytesToRecv</td><td>The expected number of bytes to receive from the server.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function SHOULD return one of the following integer codes:<ul>
<li><code>bytesToRecv</code> value if all the requested number of bytes are received from the network.</li>
<li>ZERO when no data is available on the network, and the operation can be retried.</li>
<li>&lt; 0 when the read operation failed due to internal error, and operation cannot be retried. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7f01446c0d655614b99fd4043c8f032a" name="ga7f01446c0d655614b99fd4043c8f032a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f01446c0d655614b99fd4043c8f032a">&#9670;&nbsp;</a></span>SntpGenerateAuthCode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__sntp__enum__types.html#gaef7b22d8008bbfbbc7bbea5a7a30e798">SntpStatus_t</a>(* SntpGenerateAuthCode_t) (<a class="el" href="group__sntp__struct__types.html#gaff243b342eebc2622fbb493d08663133">SntpAuthContext_t</a> *pContext, const <a class="el" href="struct_sntp_server_info__t.html">SntpServerInfo_t</a> *pTimeServer, void *pBuffer, size_t bufferSize, uint16_t *pAuthCodeSize)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface for user-defined function to generate and append authentication code in an SNTP request buffer for the SNTP client to be authenticated by the time server, if a security mechanism is used. </p>
<p >The user can choose to implement with any security mechanism, symmetric key-based (like AES-CMAC) or asymmetric key-based (like Network Time Security), depending on the security mechanism supported by the time server being used to synchronize time with.</p>
<dl class="section note"><dt>Note</dt><dd>The function SHOULD generate the authentication data for the first <a class="el" href="group__sntp__constants.html#ga9fb0febdb6e2f2dff2e133ef49ce205b" title="The base packet size of request and response of the (S)NTP protocol.">SNTP_PACKET_BASE_SIZE</a> bytes of SNTP request packet present in the passed buffer <code>pBuffer</code>, and fill the generated authentication data after <a class="el" href="group__sntp__constants.html#ga9fb0febdb6e2f2dff2e133ef49ce205b" title="The base packet size of request and response of the (S)NTP protocol.">SNTP_PACKET_BASE_SIZE</a> bytes in the buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pContext</td><td>The user defined NetworkContext_t which is opaque to the coreSNTP library. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimeServer</td><td>The time server being used to request time from. This parameter is useful to choose the security mechanism when multiple time servers are configured in the library, and they require different security mechanisms or authentication credentials to use. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pBuffer</td><td>This buffer SHOULD be filled with the authentication code generated from the <a class="el" href="group__sntp__constants.html#ga9fb0febdb6e2f2dff2e133ef49ce205b" title="The base packet size of request and response of the (S)NTP protocol.">SNTP_PACKET_BASE_SIZE</a> bytes of SNTP request data present in it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The maximum amount of data that can be held by the buffer, <code>pBuffer</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAuthCodeSize</td><td>This should be filled with size of the authentication data appended to the SNTP request buffer, <code>pBuffer</code>. This value plus <a class="el" href="group__sntp__constants.html#ga9fb0febdb6e2f2dff2e133ef49ce205b" title="The base packet size of request and response of the (S)NTP protocol.">SNTP_PACKET_BASE_SIZE</a> should not exceed the buffer size, <code>bufferSize</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function SHOULD return one of the following integer codes:<ul>
<li><a class="el" href="group__sntp__enum__types.html#ggaef7b22d8008bbfbbc7bbea5a7a30e798a8486f9ee1815b43418a9c0478bd8f016" title="Successful operation of an SNTP API.">SntpSuccess</a> when the authentication data is successfully appended to <code>pBuffer</code>.</li>
<li><a class="el" href="group__sntp__enum__types.html#ggaef7b22d8008bbfbbc7bbea5a7a30e798a23891833ba2ad8634832cbbb9d47bd9c" title="Application provided insufficient buffer space for serializing or de-serializing an SNTP packet....">SntpErrorBufferTooSmall</a> when the user-supplied buffer (to the <a class="el" href="struct_sntp_context__t.html" title="Structure for a context that stores state for managing a long-running SNTP client that periodically p...">SntpContext_t</a> through <a class="el" href="core__sntp__client_8h.html#ae7f3fa647cd74f09878af88e430707fc">Sntp_Init</a>) is not large enough to hold authentication data.</li>
<li><a class="el" href="group__sntp__enum__types.html#ggaef7b22d8008bbfbbc7bbea5a7a30e798a6db2603ebf3153c9472d3867694aa787" title="Failure from the user-supplied authentication interface, SntpAuthenticationInterface_t,...">SntpErrorAuthFailure</a> for failure to generate authentication data due to internal error. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae382a67b0ffbb4721d8d599efe3020c4" name="gae382a67b0ffbb4721d8d599efe3020c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae382a67b0ffbb4721d8d599efe3020c4">&#9670;&nbsp;</a></span>SntpValidateServerAuth_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__sntp__enum__types.html#gaef7b22d8008bbfbbc7bbea5a7a30e798">SntpStatus_t</a>(* SntpValidateServerAuth_t) (<a class="el" href="group__sntp__struct__types.html#gaff243b342eebc2622fbb493d08663133">SntpAuthContext_t</a> *pContext, const <a class="el" href="struct_sntp_server_info__t.html">SntpServerInfo_t</a> *pTimeServer, const void *pResponseData, uint16_t responseSize)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface for user-defined function to authenticate server by validating the authentication code present in its SNTP response to a time request, if a security mechanism is supported by the server. </p>
<p >The user can choose to implement with any security mechanism, symmetric key-based (like AES-CMAC) or asymmetric key-based (like Network Time Security), depending on the security mechanism supported by the time server being used to synchronize time with.</p>
<dl class="section note"><dt>Note</dt><dd>In an SNTP response, the authentication code is present only after the first <a class="el" href="group__sntp__constants.html#ga9fb0febdb6e2f2dff2e133ef49ce205b" title="The base packet size of request and response of the (S)NTP protocol.">SNTP_PACKET_BASE_SIZE</a> bytes. Depending on the security mechanism used, the first <a class="el" href="group__sntp__constants.html#ga9fb0febdb6e2f2dff2e133ef49ce205b" title="The base packet size of request and response of the (S)NTP protocol.">SNTP_PACKET_BASE_SIZE</a> bytes MAY be used in validating the authentication data sent by the server.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pContext</td><td>The user defined NetworkContext_t which is opaque to the coreSNTP library. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimeServer</td><td>The time server that has to be authenticated from its SNTP response. This parameter is useful to choose the security mechanism when multiple time servers are configured in the library, and they require different security mechanisms or authentication credentials to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pResponseData</td><td>The SNTP response from the server that contains the authentication code after the first <a class="el" href="group__sntp__constants.html#ga9fb0febdb6e2f2dff2e133ef49ce205b" title="The base packet size of request and response of the (S)NTP protocol.">SNTP_PACKET_BASE_SIZE</a> bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">responseSize</td><td>The total size of the response from the server.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function SHOULD return one of the following integer codes:<ul>
<li><a class="el" href="group__sntp__enum__types.html#ggaef7b22d8008bbfbbc7bbea5a7a30e798a8486f9ee1815b43418a9c0478bd8f016" title="Successful operation of an SNTP API.">SntpSuccess</a> when the server is successfully authenticated.</li>
<li><a class="el" href="group__sntp__enum__types.html#ggaef7b22d8008bbfbbc7bbea5a7a30e798acbefde33f8de7f9fac2c31d6a6008397" title="Time server is not authenticated from the authentication data in its response. This status can be ret...">SntpServerNotAuthenticated</a> when server could not be authenticated.</li>
<li><a class="el" href="group__sntp__enum__types.html#ggaef7b22d8008bbfbbc7bbea5a7a30e798a6db2603ebf3153c9472d3867694aa787" title="Failure from the user-supplied authentication interface, SntpAuthenticationInterface_t,...">SntpErrorAuthFailure</a> for failure to authenticate server due to internal error. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
